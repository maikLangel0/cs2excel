use std::path::PathBuf;
use rusqlite::{Result, Connection};
use whoami;

///Used to access the firefox browser cookies
pub struct FirefoxDb {
    db: Connection
}

impl FirefoxDb {
    ///Initializes the connection to cookies.sqlite
    pub fn init() -> Result<Self, String> {
        let curr_user = whoami::username();
        let profiles_path: &str = &format!("C:/Users/{}/AppData/Roaming/Mozilla/Firefox/Profiles/", curr_user);
        
        // Traverses the dir with path "profiles_path" and returns the "profiles_path/xxxxxx.stable-release" (or panics)
        // where xxxxxx is generated by firefox on install so its unique for everyone
        let user_profiles: String = std::fs::read_dir(profiles_path)
            .map_err(|_| format!("Couldn't read dir of path {}.", profiles_path))?
            .filter_map(|entry| 
                entry.ok()
                    .map(|e| 
                        e.path().to_string_lossy().to_string()
                    )
                    .filter(|path_str| 
                        path_str.ends_with("release")
                    )
            ).next()
            .ok_or(String::from("No valid Firefox profile found."))?;
        
        let db_path = PathBuf::from( format!("{}/cookies.sqlite", &user_profiles) );
        
        if !db_path.exists() { 
            return Err("No cookies.sqlite found for firefox.".to_string())
        }

        let db = Connection::open( db_path )
            .map_err(|_| String::from("Unable to open a DB Connection for firefox."))?;

        Ok( FirefoxDb{ db } )
    }

    /// select: [Vec<&str>] -> the possible things you can select from the db
    /// 
    /// host: [&str] -> the website that contains the wanted cookie(s)
    /// 
    /// names: [Vec<&str>] -> name(s) of the cookies that you want to get
    /// 
    /// Query:
    /// SELECT {select} FROM moz_cookies WHERE host LIKE '%{host}%' AND name IN ({names})
    pub fn get_cookies(self: &FirefoxDb, select: Vec<&str>, host: &str, names: Vec<&str>) -> Result<Vec<String>> {
        // Turns select into a string suitable for the query
        let select = select.iter()
            .map( |s| s.to_string() )
            .collect::<Vec<String>>()
            .join(", ");
        
        // Turns names into a string suitable for the query
        let names = names.iter()
            .map( |s| format!( "'{}'", *s ) )
            .collect::<Vec<String>>()
            .join(", ");

        // Queries the db
        let mut stmt = self.db.prepare(
            &format!(
                "SELECT {select} FROM moz_cookies WHERE host LIKE '%{host}%' AND name IN ({names})"
            )
        )?;

        // Gets all the cookies and maps them to a Vec<( (name, value) )>
        let cookies_data = stmt.query_map([], |elem| {
            Ok( (elem.get(0)?, elem.get(1)?) )
        })?
        .collect::<Result<Vec<(String, String)>>>()?;

        // Removes extra steamLoginSecure cuz for some reason theres two and one is outdated
        // if cookies_data.iter().filter(|cookie| cookie.name == "steamLoginSecure").count() > 1 {
            // cookies_data.pop();
        // }

        // Turns cookies_data into a string suitable for http requests
        let cookies = cookies_data.iter()
            .map( |c| format!("{}={};", c.0, c.1))
            .collect::<Vec<String>>();

        Ok(cookies)
    }
}