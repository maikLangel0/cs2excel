use std::{error::Error, path::PathBuf};
use rusqlite::{Result, Connection};
use crate::models::web::Cookies;
use whoami;

///Used to access the firefox browser cookies
pub struct FirefoxDb {
    db: Connection
}

impl FirefoxDb {
    ///Initializes the connection to cookies.sqlite
    pub fn init() -> Result<Self, Box<dyn Error>> {
        let curr_user = whoami::username();
        let profiles_path: &str = &format!("C:/Users/{}/AppData/Roaming/Mozilla/Firefox/Profiles/", curr_user);
        
        // Traverses the dir with path "profiles_path" and returns the "profiles_path/xxxxxx.stable-release" (or panics)
        // where xxxxxx is generated by firefox on install so its unique for everyone
        let user_profiles: String = std::fs::read_dir(profiles_path)?
            .filter_map(
                |entry| {
                    let entry = entry.unwrap();
                    let path = entry.path();
                    let path_str = path.to_string_lossy().to_string();
                    
                    if path_str.ends_with("release") { 
                        Some(path_str)
                    }
                    else { 
                        None
                    }
                }
            ).next()
            .ok_or_else(|| "No valid Firefox profile found")?;
        
        let db = Connection::open(
            PathBuf::from(
                format!("{}/cookies.sqlite", &user_profiles)
            )
        )?;

        Ok( FirefoxDb{ db } )
    }

    /// select: [Vec<&str>] -> the possible things you can select from the db
    /// 
    /// host: [&str] -> the website that contains the wanted cookie(s)
    /// 
    /// names: [Vec<&str>] -> name(s) of the cookies that you want to get
    /// 
    /// Query:
    /// SELECT {select} FROM moz_cookies WHERE host LIKE '%{host}%' AND name IN ({names})
    pub fn get_cookies(self: &FirefoxDb, select: Vec<&str>, host: &str, names: Vec<&str>) -> Result<String> {
        // Turns select into a string suitable for the query
        let select = select.iter()
            .map( |s| s.to_string() )
            .collect::<Vec<String>>()
            .join(", ");
        
        // Turns names into a string suitable for the query
        let names = names.iter()
            .map( |s| format!( "'{}'", s ) )
            .collect::<Vec<String>>()
            .join(", ");

        // Queries the db
        let mut stmt = self.db.prepare(
            &format!(
                "SELECT {select} FROM moz_cookies WHERE host LIKE '%{host}%' AND name IN ({names})"
            )
        )?;

        // Gets all the cookies and maps them to a Vec<Cookies>
        let mut cookies_data = stmt.query_map([], |elem| {
            Ok(
                Cookies {
                    name: elem.get(0)?,
                    value: elem.get(1)?
                }
            )
        })?
        .collect::<Result<Vec<Cookies>, _>>()?;

        // Removes extra steamLoginSecure cuz for some reason theres two and one is outdated
        if cookies_data.iter().filter(|cookie| cookie.name == "steamLoginSecure").count() > 1 {
            cookies_data.pop();
        }

        // Turns cookies_data into a string suitable for http requests
        let cookies = cookies_data.iter()
            .map( |c| format!("{}={};", c.name, c.value))
            .collect::<Vec<String>>()
            .join(" ");

        Ok(cookies)
    }
}